c++11中引入了移动语义，可以避免无谓的复制，提高程序性能。
c++11 测试右值 临时对象的构造 编译器会自动优化导致有些流程未打印，下面先介绍一下RVO。

RVO（Return  Value Optimization）是一种编译器优化机制：当函数需要返回一个对象的时候，如果自己创建一个临时对象返回，
那么这个临时对象会消耗一个构造函数（Constructor）、一个拷贝构造函数（Copy Constructor）以及一个析构函数（Destructor）的调用的代价，
RVO的目的就是消除为保存返回值而创建的临时对象，这样就可以将成本降低到一个构造函数的代价。

按照C++的语义，临时对象将在语句结束后被析构，会释放它所包含的堆内存资源。而a在拷贝构造的时候，又会被分配堆内存。这样的一去一来似乎并没有多大的意义.
相比于之前的代码，上例HasPtrMem类多了一个构造函数HasPtrMem（HasPtrMem&&），这个就是我们所谓的移动构造函数。与拷贝构造函数不同的是，
移动构造函数接受一个所谓的“右值引用”的参数。可以看到，移动构造函数使用了参数h的成员d初始化了本对象的成员d（而不是像拷贝构造函数一样需要分配内存，
然后将内容依次拷贝到新分配的内存中），而h的成员d随后被置为指针空值nullptr。这就完成了移动构造的全过程。
这里所谓的“偷”对内存，就是指将本对象d指向h.d所指的内存这一条语句，相应地，我们还将h的成员d置为指针空值。这其实也是我们“偷”内存是必须做的。
不然，在移动构造完成之后，临时对象会立即被析构。如果不改变h.d的话，则临时对象会析构掉本是我们“偷”来得堆内存。这样一来，就造成了悬挂指针。

移动构造函数是一个特殊的构造函数，它能够从一个右值引用（rvalue reference）创建新的对象，而无需进行深拷贝（deep copy）。
在代码中，移动构造函数使用右值引用作为参数，并且我们将原始对象的资源直接转移到新对象中，而不是进行复制,节省了时间和空间开销。
总的来说：可以理解为快速的拷贝构造函数
    基本格式:在构造函数后面写noexcept
    ClassName(ClassName&& other) noexcept
    {
        // Move the resources from 'other' to the new object
        // ...
    }

移动赋值操作符允许我们将一个对象的资源转移到另一个对象上。在代码中，移动赋值操作符也使用右值引用作为参数。
我们将源对象的资源直接转移到目标对象中，同时将源对象恢复到一种可安全销毁或重新赋值的状态。这就如同两个人交换工作岗位，互相拥有对方的资源和责任。
总的来说：可以理解为快速的赋值运算符。（比一般的更快，因为无需深拷贝）
    一般格式:
    ClassName& operator=(ClassName&& other) noexcept
    {
        // Move the resources from 'other' to the current object
        // ...
        return *this;
    }

  当我们需要在C++中处理大量数据或动态分配的对象时，移动构造函数和移动赋值操作符成为了重要的工具。它们是C++11引入的特性，旨在提高程序的性能和效率。
移动构造函数和移动赋值操作符的作用是允许将临时对象或资源所有权从一个对象转移给另一个对象，而无需执行深层的数据拷贝和分配新资源。
相比复制构造函数和复制赋值操作符，移动操作通常更加高效，因为它只需要重新指定资源的所有权关系，而不需要执行资源的复制或分配。
使用移动构造函数和移动赋值操作符的好处包括：
    1.减少不必要的数据拷贝和资源分配，提高程序的性能和效率。
    2.在处理大型对象或大量数据时，减少内存的占用和提高程序的响应速度。
    3.支持对不可拷贝的对象进行移动操作，使得这些对象也可以被移动和管理。
在使用移动操作时，需要注意以下几点：
    4.移动构造函数和移动赋值操作符通常会将被移动对象的资源指针设置为nullptr，以避免资源的重复释放。
    5.移动构造函数和移动赋值操作符通常应该具有noexcept规定，表示它们不会抛出异常。
    6.移动操作并不会自动删除或释放资源，只是转移资源的所有权关系。移动后的对象需要负责管理和释放资源。移动后的源对象状态通常不可预测，应当谨慎使用。
    7.使用移动操作时，对象的移后状态应该仍然是有效且可用的。

emplace_back函数解析:
emplace_back也是添加元素的函数，只不过和vector容器的push_back()的区别在于：
push_back()方法要调用构造函数和复制构造函数，这也就代表着要先构造一个临时对象，然后把临时的copy构造函数拷贝移动到容器最后面。
而emplace_back()在实现时，则是直接在容器的尾部创建这个元素，省去了拷贝或移动元素的过程。
    vector<pair<int, int>> ret;
    ret.push_back(1,1)//会报错，因为没有构造一个临时对象
    ret.push_back(pair(1,1))//不会报错，因为构成了一个pair对象
    ret.emplace_back(1,1)//不会报错，因为直接在容器的尾部创建对象

    使用vector::emplace_back 需做一次构造函数
    使用vector::push_back(value_type&& val) 需做一次构造函数和一次移动构造函数
    使用vector::push_back(const value_type& val)需做一次构造函数和一次拷贝构造函数
    使用map::insert(const value_type& val) 需做一次构造函数，2次移动构造函数
    使用map::empalce(Args&&... args) 需做一次构造函数，1次移动构造函数

总之，emplace系列总是会少一次移动构造函数或一次拷贝构造函数；

unordered_map:

    最近使用到一个c++的容器——unordered_map，它是一个关联容器，内部采用的是hash表结构，拥有快速检索的功能。
    关联性：一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。通过key去检索value，而不是通过绝对地址（和顺序容器不同）
    无序性：使用hash表存储，内部无序，可以使用[]操作符来访问key值对应的value值。
    Map : 每个值对应一个键值
    键唯一性：不存在两个元素的键一样
    动态内存管理：使用内存管理模型来动态管理所需要的内存空间
    由于unordered_map内部采用的hashtable的数据结构存储，所以，每个特定的key会通过一些特定的哈希运算映射到一个特定的位置，
    我们知道，hashtable是可能存在冲突的（多个key通过计算映射到同一个位置），在同一个位置的元素会按顺序链在后面。
    所以把这个位置称为一个bucket是十分形象的（像桶子一样，可以装多个元素）。
    1)元素在容器无顺序，不提供按顺序遍历
    2）在极端条件下，查找时间复杂度不是O(1)，用的时间复杂度会提高很多
    3）占用的空间可能会更多
    4）在1000W以上不如set，hash冲突，性能降低很多；1000W以下就比set好
    所以unordered_map内部其实是由很多哈希桶组成的，每个哈希桶中可能没有元素，也可能有多个元素。

unordered_set:

    unordered_set 容器提供了和 unordered_map 相似的能力，但unordered_set可以用保存的元素作为它们自己的键。
    T 类型的对象在容器中的位置由它们的哈希值决定，因而需要定义一个 Hash< T > 函数。基本类型可以省去Hash< T >方法。
    不能存放重复元素。
    1、无序集是一种容器，它以不特定的顺序存储惟一的元素，并允许根据元素的值快速检索单个元素。
    2、在unordered_set中，元素的值同时是唯一标识它的键。键是不可变的，只可增删，不可修改
    3、在内部，unordered_set中的元素没有按照任何特定的顺序排序，而是根据它们的散列值组织成桶，从而允许通过它们的值直接快速访问单个元素(平均时间复杂度为常数)。
    4、unordered_set容器比set容器更快地通过它们的键访问单个元素，尽管它们在元素子集的范围迭代中通常效率较低。
    5、容器中的迭代器至少是前向迭代器。

向set集合中插入元素时，可根据set.insert().second的返回值判断集合中是否已有该元素。







